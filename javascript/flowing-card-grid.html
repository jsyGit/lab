<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>card grid</title>
	<script type="text/javascript" src="../libs/jquery-2.1.4.min.js"></script>
	<style type="text/css">
		* {
			box-sizing: border-box;
		}
		div {
			border: 1px solid #f00;
		}
		.container{
			width: 1000px;
			position: relative;
		}
		.card {
			transition: all 0.4s ease;
			position: absolute;
		}
	</style>

</head>
<body>


<script type="text/javascript">

	'use strict';

	var cards = [
		{
			width: 1,
			height: 2,
			posX: undefined,
			posY: undefined,
			content: 'card 1'
		},
		{
			width: 1,
			height: 2,
			posX: undefined,
			posY: undefined,
			content: 'card 1'
		},
		{
			width: 1,
			height: 1,
			posX: undefined,
			posY: undefined,
			content: 'card 1'
		},
		{
			width: 1,
			height: 1,
			posX: undefined,
			posY: undefined,
			content: 'card 1'
		},
		{
			width: 2,
			height: 2,
			posX: undefined,
			posY: undefined,
			content: 'card 1'
		},
		{
			width: 2,
			height: 1,
			posX: undefined,
			posY: undefined,
			content: 'card 1'
		}
	];

	var container_width = 4,
		base_size = 250,
		tiles = [],
		card_area,
		isCardPositionSet, // check if a card got it's own position
		cur_y;

	// traverse cards
	for (var card_idx = 0; card_idx < cards.length; card_idx++) {

		// init x=0, y=0
		cur_y = 0;
		isCardPositionSet = false;

		var brk = 0;
		// while( !isCardPositionSet || brk < 10){
		while( !isCardPositionSet ) {

			// traverse x position wihin container width
			for (var cur_x = 0; cur_x < container_width; cur_x++) {
				card_area = new Array();

				// 현재 위치에서 가로 넓이가 컨테이너 넓이를 넘지 않아야 한다.
				if(cur_x + cards[card_idx].width > container_width){
					break;
				}

				// console.log(cards[card_idx].width);
				// console.log(cards[card_idx].height);

				// make card area
				for (var temp_x = cur_x; temp_x < cur_x + cards[card_idx].width ; temp_x++) {
					for (var temp_y = cur_y; temp_y < cur_y + cards[card_idx].height ; temp_y++) {
						card_area.push(createTile(temp_x, temp_y));
						// console.log(temp_x, temp_y);
					}
				}

				// console.log(card_area);
				// console.log('tiles', tiles);

				var isDuplicate = false;
				for (var chk_cidx = 0; chk_cidx < card_area.length; chk_cidx++) {
					for (var chk_tidx = 0; chk_tidx < tiles.length; chk_tidx++) {

						if( (card_area[chk_cidx].x === tiles[chk_tidx].x)
							&& (card_area[chk_cidx].y === tiles[chk_tidx].y) ){
							// 카드 영역과 타일 영역 중에 겹치는 부분이 있음
							isDuplicate = true;
						}
					}
				}

				if( isDuplicate === true ){
					isCardPositionSet = false;
				}else{
					// 포지션을 찾았음. 더이상 컨테이너 내부를 탐색할 필요 없음
					isCardPositionSet = true;
					// 카드 영역을 타일에 추가
					for (var i = 0; i < card_area.length; i++) {
						tiles.push(card_area[i]);
					}

					cards[card_idx].posX = cur_x;
					cards[card_idx].posY = cur_y;

					// console.log(cur_x, cur_y);
					break; // break traversing container
				}

			};

			if(isCardPositionSet){
				break; // break infinite while loop
			}else{
				cur_y++;
			}

		}// end of while( !isCardPositionSet )

	};// end of for (var card_idx = 0; card_idx < cards.length; card_idx++)

	console.log('cards', cards);


	$(document).ready(function() {
		var $card_box = $('.card');
		for (var i = 0; i < $card_box.length; i++) {
			// console.log($card_box.eq(i));
			$card_box.eq(i).css('width', (cards[i].width * base_size) );
			$card_box.eq(i).css('height', (cards[i].height * base_size) );
			$card_box.eq(i).css('left', (cards[i].posX * base_size) );
			$card_box.eq(i).css('top', (cards[i].posY * base_size) );
		}

	});


	function createTile (posX, posY) {
		return { x: posX, y: posY }
	}

</script>
</body>

<div class="container">
	<div class="card">1</div>
	<div class="card">2</div>
	<div class="card">3</div>
	<div class="card">4</div>
	<div class="card">5</div>
	<div class="card">6</div>
</div>
</html>